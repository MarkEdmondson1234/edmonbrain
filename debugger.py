from langchain.prompts import ChatPromptTemplate
from langchain.retrievers import GoogleCloudEnterpriseSearchRetriever
from utils.gcp import get_gcp_project
from google.cloud import discoveryengine_v1
#client = discoveryengine_v1.DocumentServiceClient()

SEARCH_ENGINE_ID = 'longterm-conversation-memo_1694023932257'
GCP_PROJECT = 'devo-mark-sandbox'
print(f'Search engine: {SEARCH_ENGINE_ID}')
gcp_retriever = GoogleCloudEnterpriseSearchRetriever(
    project_id=GCP_PROJECT,
    search_engine_id=SEARCH_ENGINE_ID,
    location_id="global",
    engine_data_type=0, #unstructured
    query_expansion_condition=2,
    filter=None, # want this to be generated by LLM
    spell_correction_mode=2
)


## This is only needed for Unstrucutred data with metadata added to a supporting bucket
template = """Using the search filter expression using an Extended Backusâ€“Naur form specification below, create a filter that will reflect the question asked.
If no filter is aavailable, return "No filter" instead.
# A single expression or multiple expressions that are joined by "AND" or "OR".
  filter = expression, {{ " AND " | "OR", expression }};
  # Expressions can be prefixed with "-" or "NOT" to express a negation.
  expression = [ "-" | "NOT " ],
    # A parenthetical expression.
    | "(", expression, ")"
    # A simple expression applying to a text field.
    # Function "ANY" returns true if the field contains any of the literals.
    ( text_field, ":", "ANY", "(", literal, {{ ",", literal }}, ")"
    # A simple expression applying to a numerical field. Function "IN" returns true
    # if a field value is within the range. By default, lower_bound is inclusive and
    # upper_bound is exclusive.
    | numerical_field, ":", "IN", "(", lower_bound, ",", upper_bound, ")"
    # A simple expression that applies to a numerical field and compares with a double value.
    | numerical_field, comparison, double );
  # A lower_bound is either a double or "*", which represents negative infinity.
  # Explicitly specify inclusive bound with the character 'i' or exclusive bound
  # with the character 'e'.
  lower_bound = ( double, [ "e" | "i" ] ) | "*";
  # An upper_bound is either a double or "*", which represents infinity.
  # Explicitly specify inclusive bound with the character 'i' or exclusive bound
  # with the character 'e'.
  upper_bound = ( double, [ "e" | "i" ] ) | "*";
  # Supported comparison operators.
  comparison = "<=" | "<" | ">=" | ">" | "=";
  # A literal is any double quoted string. You must escape backslash (\) and
  # quote (") characters.
  literal = double quoted string;
  text_field = a text string;
  numerical_field = a numerical value;
Examples:
  Question: 
  Filter:
  Question:
  Filter:

Question: {question}
Filter:"""
prompt = ChatPromptTemplate.from_template(template)


from operator import itemgetter

from langchain.chat_models import ChatOpenAI
from langchain.schema.output_parser import StrOutputParser
from langchain.schema.runnable import RunnableLambda, RunnableMap

model = ChatOpenAI()
print('loaded model')
inputs = {
    "question": itemgetter("question")
}
sql_response = (
        RunnableMap(inputs)
        | prompt
        | model.bind(stop=["\nFilter:"])
        | StrOutputParser()
    )

response = sql_response.invoke({"question": "What happened last week?"})
print(response)




# template = """Based on the table schema below, question, sql query, and sql response, write a natural language response:
# {schema}

# Question: {question}
# SQL Query: {query}
# SQL Response: {response}"""
# prompt_response = ChatPromptTemplate.from_template(template)

# full_chain = (
#     RunnableMap({
#         "question": itemgetter("question"),
#         "query": sql_response,
#     }) 
#     | {
#         "schema": RunnableLambda(get_schema),
#         "question": itemgetter("question"),
#         "query": itemgetter("query"),
#         "response": lambda x: db.run(x["query"])    
#     } 
#     | prompt_response 
#     | model
# )

